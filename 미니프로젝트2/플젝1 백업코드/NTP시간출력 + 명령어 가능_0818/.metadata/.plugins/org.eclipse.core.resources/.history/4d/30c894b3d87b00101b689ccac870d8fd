//ì„œìš¸ê¸°ìˆ êµìœ¡ì„¼í„° AIOT & Embedded System
//2024-04-16 By KSH

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "esp.h"
#include <time.h>
#include "FreeRTOS.h"   // ì¶”ê°€
#include "task.h"       // ì¶”ê°€

static char ip_addr[16];
char response[MAX_ESP_RX_BUFFER];

#define NTP_SERVER "time.kriss.re.kr"
#define NTP_PORT   123
#define NTP_PACKET_SIZE 48

//==================uart2=========================
extern UART_HandleTypeDef huart2;
volatile unsigned char rx2Flag = 0;
volatile char rx2Data[50];
uint8_t cdata;

//==================uart6=========================
//extern volatile unsigned char rx2Flag;
//extern volatile char rx2Data[50];
//extern uint8_t cdata;
static uint8_t data;
cb_data_t cb_data;
extern UART_HandleTypeDef huart6;

// NTP ê´€ë ¨ í•¨ìˆ˜ ì„ ì–¸

int esp_at_command(uint8_t *cmd, uint8_t *resp, uint16_t *length, int16_t time_out)
{
	*length = 0;
	memset(resp, 0x00, MAX_UART_RX_BUFFER);
	memset(&cb_data, 0x00, sizeof(cb_data_t));

	// ëª…ë ¹ ì†¡ì‹ 
	if (HAL_UART_Transmit(&huart6, cmd, strlen((char *)cmd), 100) != HAL_OK)
		return -1;

	while (time_out > 0)
	{
		if (cb_data.length >= MAX_UART_RX_BUFFER)
			return -2;
		else if (strstr((char *)cb_data.buf, "ERROR") != NULL)
			return -3;
		else if (strstr((char *)cb_data.buf, "CLOSED") != NULL)   // ğŸ”¥ TCP ëŠê¹€ ê°ì§€
		{
			printf("ESP: TCP connection closed.\r\n");
			esp_client_conn();   // ìë™ ì¬ì—°ê²°
			return -5;
		}
		else if (strstr((char *)cb_data.buf, "OK") != NULL)
		{
			memcpy(resp, cb_data.buf, cb_data.length);
			*length = cb_data.length;
			return 0;
		}

		time_out -= 10;
		HAL_Delay(10);
	}
	return -4; // Timeout
}

// í•œ ì¤„ì”© ESP ì‘ë‹µ ì½ê¸°

static int esp_read_line(char *buf, int buf_size, int timeout_ms)
{
    int i = 0;
    int elapsed = 0;

    memset(buf, 0, buf_size);

    while (elapsed < timeout_ms)
    {
        if (cb_data.length > 0)
        {
            char c = cb_data.buf[0];

            // ë²„í¼ ì•ìœ¼ë¡œ ì´ë™
            memmove(cb_data.buf, cb_data.buf + 1, cb_data.length - 1);
            cb_data.length--;

            if (c == '\n' || c == '\r')
            {
                if (i == 0) // ë¹ˆ ì¤„ ë¬´ì‹œ
                    continue;
                buf[i] = 0;
                return i; // ì½ì€ ê¸¸ì´ ë°˜í™˜
            }

            if (i < buf_size - 1)
                buf[i++] = c;
        }
        else
        {
            HAL_Delay(1);
            elapsed += 1;
        }
    }
    return 0; // íƒ€ì„ì•„ì›ƒ
}


static int esp_reset(void)
{
    uint16_t length = 0;
    if(esp_at_command((uint8_t *)"AT+RST\r\n", (uint8_t *)response, &length, 1000) != 0)
    {
    	return -1;
    }
    else
    	HAL_Delay(500);	//reboot
    return 0;
}

static int esp_get_ip_addr(uint8_t is_debug)
{
    if(strlen(ip_addr) != 0)
    {
        if(strcmp(ip_addr, "0.0.0.0") == 0)
            return -1;
    }
    else
    {
        uint16_t length;
        if(esp_at_command((uint8_t *)"AT+CIPSTA?\r\n", (uint8_t *)response, &length, 1000) != 0)
            printf("ip_state command fail\r\n");
        else
        {
            char *line = strtok(response, "\r\n");

            if(is_debug)
            {
                for(int i = 0 ; i < length ; i++)
                    printf("%c", response[i]);
            }

            while(line != NULL)
            {
                if(strstr(line, "ip:") != NULL)
                {
                    char *ip;

                    strtok(line, "\"");
                    ip = strtok(NULL, "\"");
                    if(strcmp(ip, "0.0.0.0") != 0)
                    {
                        memset(ip_addr, 0x00, sizeof(ip_addr));
                        memcpy(ip_addr, ip, strlen(ip));
                        return 0;
                    }
                }
                line = strtok(NULL, "\r\n");
            }
        }

        return -1;
    }

    return 0;
}

static int request_ip_addr(uint8_t is_debug)
{
    uint16_t length = 0;

    if(esp_at_command((uint8_t *)"AT+CIFSR\r\n", (uint8_t *)response, &length, 1000) != 0)
        printf("request ip_addr command fail\r\n");
    else
    {
        char *line = strtok(response, "\r\n");

        if(is_debug)
        {
            for(int i = 0 ; i < length ; i++)
                printf("%c", response[i]);
        }

        while(line != NULL)
        {
            if(strstr(line, "CIFSR:STAIP") != NULL)
            {
                char *ip;

                strtok(line, "\"");
                ip = strtok(NULL, "\"");
                if(strcmp(ip, "0.0.0.0") != 0)
                {
                    memset(ip_addr, 0x00, sizeof(ip_addr));
                    memcpy(ip_addr, ip, strlen(ip));
                    return 0;
                }
            }
            line = strtok(NULL, "\r\n");
        }
    }
    return -1;
}

int esp_client_conn()
{
    char at_cmd[MAX_ESP_COMMAND_LEN] = {0,};
    uint16_t length = 0;

    // ë§í¬ID 0ì— ì„œë²„ TCP ì—°ê²°
    snprintf(at_cmd, sizeof(at_cmd), "AT+CIPSTART=0,\"TCP\",\"%s\",%d\r\n", DST_IP, DST_PORT);
    if (esp_at_command((uint8_t*)at_cmd, (uint8_t*)response, &length, 10000) != 0) {
        printf("SERVER CIPSTART fail\r\n");
        return -1;
    }

    // ë¡œê·¸ì¸ ë“± ì´ˆê¸° ì†¡ì‹ ë„ ë§í¬ID 0ë¡œ
    esp_send_data_id(0, "["LOGID":"PASSWD"]");
    return 0;
}

int esp_get_status()
{
	uint16_t length = 0;
	esp_at_command((uint8_t *)"AT+CIPSTATUS\r\n",(uint8_t *)response, &length, 1000);					//CONNECT

    if(strstr((char *)response, "STATUS:3") != NULL)  //STATUS:3 The ESP8266 Station has created a TCP or UDP transmission
    {
    	return 0;
    }
	return -1;
}
int drv_esp_init(void)
{
    memset(ip_addr, 0x00, sizeof(ip_addr));
    HAL_UART_Receive_IT(&huart6, &data, 1);

    if (esp_reset() != 0) return -1;

    uint16_t length = 0;
    // ğŸ”´ ë©€í‹° ì—°ê²° ëª¨ë“œ ON
    (void)esp_at_command((uint8_t*)"AT+CIPMUX=1\r\n", (uint8_t*)response, &length, 2000);

    return 0;
}

void reset_func()
{
	printf("esp reset... ");
	if(esp_reset() == 0)
			printf("OK\r\n");
	else
			printf("fail\r\n");
}

void version_func()
{
  uint16_t length = 0;
  printf("esp firmware version\r\n");
  if(esp_at_command((uint8_t *)"AT+GMR\r\n", (uint8_t *)response, &length, 1000) != 0)
      printf("ap scan command fail\r\n");
  else
  {
      for(int i = 0 ; i < length ; i++)
          printf("%c", response[i]);
  }
}

void ap_conn_func(char *ssid, char *passwd)
{
  uint16_t length = 0;
  char at_cmd[MAX_ESP_COMMAND_LEN] = {0, };
  if(ssid == NULL || passwd == NULL)
  {
      printf("invalid command : ap_conn <ssid> <passwd>\r\n");
      return;
  }
  if(esp_at_command((uint8_t *)"AT+CWMODE=1\r\n", (uint8_t *)response, &length, 1000) != 0)
      printf("Station mode fail\r\n");
  sprintf(at_cmd, "AT+CWJAP=\"%s\",\"%s\"\r\n", ssid,passwd);
  if(esp_at_command((uint8_t *)at_cmd, (uint8_t *)response, &length, 6000) != 0)
      printf("ap scan command fail : %s\r\n",at_cmd);
}

void ip_state_func()
{
  uint16_t length = 0;
  if(esp_at_command((uint8_t *)"AT+CWJAP?\r\n", (uint8_t *)response, &length, 1000) != 0)
      printf("ap connected info command fail\r\n");
  else
  {
      for(int i = 0 ; i < length ; i++)
          printf("%c", response[i]);
  }
  printf("\r\n");

  if(esp_get_ip_addr(1) == 0)
      printf("ip_addr = [%s]\r\n", ip_addr);
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if(huart->Instance == USART6)  // ESP
    {
        if(cb_data.length < MAX_ESP_RX_BUFFER)
        {
            cb_data.buf[cb_data.length++] = data;
            if(data == '\n')   // í•œ í”„ë ˆì„ ë ì´ë¶€ë¶„ ìˆ˜ì •
            {
                cb_data.new_data = 1; // Taskì—ì„œ ì²˜ë¦¬í•˜ë„ë¡ ì‹ í˜¸
            }
        }
        HAL_UART_Receive_IT(huart, &data, 1);
    }

    if(huart->Instance == USART2)  // ì½˜ì†”
    {
        static int i = 0;
        rx2Data[i] = cdata;
        if(rx2Data[i] == '\r')
        {
            rx2Data[i] = '\0';
            rx2Flag = 1;
            i = 0;
        }
        else
        {
            i++;
        }
        HAL_UART_Receive_IT(huart, &cdata, 1);
    }
}



void AiotClient_Init()
{
	reset_func();
	version_func();
	//ip_state_func();
	ap_conn_func(SSID,PASS);
	request_ip_addr(1);
	esp_client_conn();
	esp_get_status();
}


// ë§í¬ID ì§€ì • ì „ì†¡
int esp_send_data_id(int link_id, const char *data)
{
    char at_cmd[64];
    uint16_t length = 0;
    int len = strlen(data);

    snprintf(at_cmd, sizeof(at_cmd), "AT+CIPSEND=%d,%d\r\n", link_id, len);
    if (esp_at_command((uint8_t*)at_cmd, (uint8_t*)response, &length, 2000) != 0)
        return -1;

    if (HAL_UART_Transmit(&huart6, (uint8_t*)data, len, 2000) != HAL_OK)
        return -2;

    return 0;
}

void esp_send_data(char *data)   // ê¸°ì¡´ í•¨ìˆ˜ëŠ” link 0ë¡œ ê³ ì •
{
    (void)esp_send_data_id(0, data);
}


//==================uart2=========================
int drv_uart_init(void)
{
    HAL_UART_Receive_IT(&huart2, &cdata,1);
    return 0;
}

int drv_uart_tx_buffer(uint8_t *buf, uint16_t size)
{
    if(HAL_UART_Transmit(&huart2, buf, size, 100) != HAL_OK)
        return -1;

    return 0;
}
int __io_putchar(int ch)
{
    if(HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 10) == HAL_OK)
        return ch;
    return -1;
}

// AT+CIPSNTPTIME? ê²°ê³¼ í•œ ì¤„ íŒŒì‹±
int parse_cipsntptime_line(const char *line, time_t *epoch_out)
{
    // ì˜ˆ: +CIPSNTPTIME:Thu Aug 17 15:24:30 2023
    struct tm tm_info;
    memset(&tm_info, 0, sizeof(struct tm));

    if (strstr(line, "+CIPSNTPTIME:") == NULL)
        return -1;

    // ë¬¸ìì—´ íŒŒì‹±
    char weekday[4], month[4];
    int day, year, hour, min, sec;

    int ret = sscanf(line, "+CIPSNTPTIME:%3s %3s %d %d:%d:%d %d",
                     weekday, month, &day, &hour, &min, &sec, &year);

    if (ret == 7)
    {
        if (strcmp(month, "Jan") == 0) tm_info.tm_mon = 0;
        else if (strcmp(month, "Feb") == 0) tm_info.tm_mon = 1;
        else if (strcmp(month, "Mar") == 0) tm_info.tm_mon = 2;
        else if (strcmp(month, "Apr") == 0) tm_info.tm_mon = 3;
        else if (strcmp(month, "May") == 0) tm_info.tm_mon = 4;
        else if (strcmp(month, "Jun") == 0) tm_info.tm_mon = 5;
        else if (strcmp(month, "Jul") == 0) tm_info.tm_mon = 6;
        else if (strcmp(month, "Aug") == 0) tm_info.tm_mon = 7;
        else if (strcmp(month, "Sep") == 0) tm_info.tm_mon = 8;
        else if (strcmp(month, "Oct") == 0) tm_info.tm_mon = 9;
        else if (strcmp(month, "Nov") == 0) tm_info.tm_mon = 10;
        else if (strcmp(month, "Dec") == 0) tm_info.tm_mon = 11;

        tm_info.tm_mday = day;
        tm_info.tm_hour = hour;
        tm_info.tm_min  = min;
        tm_info.tm_sec  = sec;
        tm_info.tm_year = year - 1900;

        *epoch_out = mktime(&tm_info);
        return 0;
    }
    return -1;
}

int esp_ntp_config(void)
{
    char cmd[128];
    sprintf(cmd, "AT+CIPSNTPCFG=1,9,\"%s\"\r\n", NTP_SERVER);
    if(HAL_UART_Transmit(&huart6, (uint8_t *)cmd, strlen(cmd), 100) != HAL_OK)
        return -1;

    vTaskDelay(pdMS_TO_TICKS(2000)); // ì„¤ì • ë°˜ì˜ ëŒ€ê¸°
    return 0;
}

void get_base_datetime(char *base_date_str, size_t date_len,
                       char *base_time_str, size_t time_len)
{
    time_t now = time(NULL);
    struct tm *tm_info = localtime(&now);

    int hour = tm_info->tm_hour;
    int min  = tm_info->tm_min;

    // ì´ˆë‹¨ê¸°ì‹¤í™©: ë³´í†µ 30ë¶„ ë‹¨ìœ„ (xx30) ê¸°ì¤€ ì‹œê°„ ì‚¬ìš© ê¶Œì¥
    if (min < 30) {
        hour -= 1;
        if (hour < 0) {
            hour = 23;
            tm_info->tm_mday -= 1;
            mktime(tm_info); // ë‚ ì§œ ë³´ì •
        }
        snprintf(base_time_str, time_len, "%02d30", hour);
    } else {
        snprintf(base_time_str, time_len, "%02d30", hour);
    }

    strftime(base_date_str, date_len, "%Y%m%d", tm_info);
}

// ìµœì†Œ ì˜ì¡´: huart6, esp_at_command(), esp_read_line(), response[]
// ì„œìš¸ ê°•ì„œêµ¬ nx=58, ny=126
// ====== ì´ˆë‹¨ê¸°ì‹¤í™© í˜¸ì¶œ (HTTPS, SSL) ======
// ì„œìš¸ ê°•ì„œêµ¬ nx=58, ny=126
// +IPD ë°ì´í„° ì¤‘ì—ì„œ íŠ¹ì • link_id(ì˜ˆ: 1)ë§Œ ì¶”ë ¤ì„œ outBufë¡œ ëª¨ìœ¼ëŠ” ê°„ë‹¨ ë¦¬ë”
static void read_http_response_from_link(int want_id, char *outBuf, size_t outSize, int timeout_ms)
{
    char line[256];
    size_t used = 0;
    int idle = timeout_ms / 200; // 200ms * n

    memset(outBuf, 0, outSize);

    while (idle-- > 0)
    {
        int got = esp_read_line(line, sizeof(line), 200); // 200ms
        if (got <= 0) continue;

        // ë©€í‹°ëª¨ë“œ +IPD í—¤ë”: +IPD,<id>,<len>:<data...
        // ì—¬ê¸°ì„œëŠ” ë¼ì¸ ë‹¨ìœ„ë¡œ ë‹¨ìˆœíˆ ëˆ„ì (ì‹¤ì œë¡œëŠ” <len>ë§Œí¼ ë°”ì´íŠ¸ ê¸°ë°˜ìœ¼ë¡œ ëª¨ìœ¼ëŠ” ê²Œ ê°€ì¥ ì •í™•)
        if (strstr(line, "+IPD,") != NULL) {
            // link id í™•ì¸
            int id = -1;
            sscanf(line, "+IPD,%d,", &id);
            if (id == want_id) {
                size_t L = strlen(line);
                if (used + L + 2 < outSize) {
                    memcpy(outBuf + used, line, L);
                    used += L;
                    outBuf[used++] = '\n';
                    outBuf[used] = 0;
                }
                idle = (timeout_ms / 200) / 2; // ë°ì´í„°ê°€ ì˜¤ë©´ ì¡°ê¸ˆ ë” ê¸°ë‹¤ë¦¼
            }
        } else {
            // OK/ERROR/HTTP í—¤ë”ê°€ ë¼ì¸ìœ¼ë¡œ ì˜¬ ìˆ˜ë„ ìˆìœ¼ë‹ˆ, ì¼ë‹¨ ê°™ì€ ë²„í¼ì— í•©ì³ë‘ 
            size_t L = strlen(line);
            if (used + L + 2 < outSize) {
                memcpy(outBuf + used, line, L);
                used += L;
                outBuf[used++] = '\n';
                outBuf[used] = 0;
            }
        }
    }
}

// ì´ˆë‹¨ê¸°ì‹¤í™©(í˜„ì¬) - ë§í¬ID 1 ì‚¬ìš©
int esp_weather_ultra_request(const char *apiKey, int nx, int ny, char *outBuf, size_t outSize)
{
    uint16_t length = 0;

    // DNS/SSL ì„¤ì •(í•œ ë²ˆë§Œ í•´ë„ ë˜ì§€ë§Œ ì•ˆì „í•˜ê²Œ)
    (void)esp_at_command((uint8_t*)"AT+CIPSSLSIZE=4096\r\n", (uint8_t*)response, &length, 2000);
    (void)esp_at_command((uint8_t*)"AT+CIPSSLCCONF=0\r\n",   (uint8_t*)response, &length, 2000);

    // ë§í¬ID 1ë¡œ SSL ì—°ê²°
    if (esp_at_command((uint8_t*)"AT+CIPSTART=1,\"SSL\",\"apihub.kma.go.kr\",443\r\n",
                       (uint8_t*)response, &length, 20000) != 0) {
        printf("CIPSTART(1) SSL fail\r\n");
        return -1;
    }

    // ë‚ ì§œ/ì‹œê°„ ê³„ì‚°
    char base_date_str[16], base_time_str[16];
    get_base_datetime(base_date_str, sizeof(base_date_str), base_time_str, sizeof(base_time_str));

    // GET êµ¬ì„± (ì‚¬ìš©ìê°€ ì œê³µí•œ HUB ê²½ë¡œ/íŒŒë¼ë¯¸í„°)
    char httpReq[700];
    snprintf(httpReq, sizeof(httpReq),
        "GET /api/typ02/openApi/VilageFcstInfoService_2.0/getUltraSrtNcst"
        "?pageNo=1&numOfRows=1000&dataType=XML"
        "&base_date=%s&base_time=%s&nx=%d&ny=%d&authKey=%s HTTP/1.1\r\n"
        "Host: apihub.kma.go.kr\r\n"
        "Connection: close\r\n\r\n",
        base_date_str, base_time_str, nx, ny, apiKey);

    // ë§í¬ID 1ë¡œ ì „ì†¡
    char cmd[48];
    snprintf(cmd, sizeof(cmd), "AT+CIPSEND=1,%d\r\n", (int)strlen(httpReq));
    if (esp_at_command((uint8_t*)cmd, (uint8_t*)response, &length, 5000) != 0) {
        printf("CIPSEND(1) fail\r\n");
        (void)esp_at_command((uint8_t*)"AT+CIPCLOSE=1\r\n", (uint8_t*)response, &length, 1000);
        return -2;
    }
    if (HAL_UART_Transmit(&huart6, (uint8_t*)httpReq, strlen(httpReq), 5000) != HAL_OK) {
        printf("payload(1) tx fail\r\n");
        (void)esp_at_command((uint8_t*)"AT+CIPCLOSE=1\r\n", (uint8_t*)response, &length, 1000);
        return -3;
    }

    // ë§í¬ID 1 ì‘ë‹µë§Œ ëª¨ì•„ì˜¤ê¸°
    read_http_response_from_link(1, outBuf, outSize, 6000);

    // ë§í¬ID 1ë§Œ ë‹«ê¸° (ì„œë²„ ì—°ê²°(link 0)ì€ ìœ ì§€)
    (void)esp_at_command((uint8_t*)"AT+CIPCLOSE=1\r\n", (uint8_t*)response, &length, 2000);

    // ê°„ë‹¨ ìƒíƒœ í™•ì¸
    if (strstr(outBuf, "HTTP/1.1 200") == NULL) {
        printf("weather http status not 200\r\n");
        return -4;
    }
    return 0;
}


// ====== ì´ˆë‹¨ê¸°ì‹¤í™© íŒŒì„œ: T1H(ê¸°ì˜¨), REH(ìŠµë„), PTY(ê°•ìˆ˜í˜•íƒœ) ======
static const char* skip_headers(const char *s)
{
    if (!s) return NULL;
    while (*s && *s!='{' && *s!='[') s++;
    return *s ? s : NULL;
}

static int pick_obsr(const char *json, const char *cat, char *out, size_t n){
    // "category":"T1H" â†’ ê°™ì€ item ë¸”ë¡ì—ì„œ "obsrValue":"ê°’" ì¶”ì¶œ
    char key[40]; snprintf(key,sizeof(key),"\"category\":\"%s\"",cat);
    const char *p = strstr(json, key);
    if(!p) return -1;
    const char *k = strstr(p, "\"obsrValue\":\"");
    if(!k) return -1;
    k = strchr(k, '\"'); if(!k) return -1;
    k++;
    const char *q = strchr(k, '\"'); if(!q) return -1;
    size_t len = (size_t)(q-k); if(len>=n) len=n-1;
    memcpy(out,k,len); out[len]=0;
    return 0;
}

void parse_weather_now(const char *resp_all)
{
    const char *json = skip_headers(resp_all);
    if(!json){ printf("weather: invalid http\r\n"); return; }

    char t1h[12]={0}, reh[12]={0}, pty[8]={0};

    (void)pick_obsr(json,"T1H",t1h,sizeof(t1h)); // ê¸°ì˜¨(â„ƒ)
    (void)pick_obsr(json,"REH",reh,sizeof(reh)); // ìŠµë„(%)
    (void)pick_obsr(json,"PTY",pty,sizeof(pty)); // ê°•ìˆ˜í˜•íƒœ(0~4)

    printf("[ê°•ì„œêµ¬ í˜„ì¬]\r\n");
    if(t1h[0]) printf("ê¸°ì˜¨: %sÂ°C\r\n", t1h); else printf("ê¸°ì˜¨: -\r\n");
    if(reh[0]) printf("ìŠµë„: %s%%\r\n", reh); else printf("ìŠµë„: -\r\n");

    if(pty[0]) {
        int code = atoi(pty);
        const char* rain =
            (code==0)?"ê°•ìˆ˜ ì—†ìŒ":(code==1)?"ë¹„":(code==2)?"ë¹„/ëˆˆ":(code==3)?"ëˆˆ":(code==4)?"ì†Œë‚˜ê¸°":"ê¸°íƒ€";
        printf("ê°•ìˆ˜í˜•íƒœ: %s (ì½”ë“œ:%d)\r\n", rain, code);
    } else {
        printf("ê°•ìˆ˜í˜•íƒœ: -\r\n");
    }
}

