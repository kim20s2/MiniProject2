/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <stdio.h>
#include <string.h>
#include "esp.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#ifdef __GNUC__
/* With GCC, small printf (option LD Linker->Libraries->Small printf
   set to 'Yes') calls __io_putchar() */
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif /* __GNUC__ */
#define ARR_CNT 5
#define CMD_SIZE 50

// LED/FAN 제어 매크로 (없다면 직접 HAL_GPIO_WritePin으로 대체)
#define LED_ON()   HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET)
#define LED_OFF()  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET)
#define FAN_ON()   HAL_GPIO_WritePin(FAN_GPIO_Port, FAN_Pin, GPIO_PIN_SET)
#define FAN_OFF()  HAL_GPIO_WritePin(FAN_GPIO_Port, FAN_Pin, GPIO_PIN_RESET)

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
RTC_HandleTypeDef hrtc;

TIM_HandleTypeDef htim3;

UART_HandleTypeDef huart2;
UART_HandleTypeDef huart6;

/* Definitions for AiotTask */
osThreadId_t AiotTaskHandle;
const osThreadAttr_t AiotTask_attributes = {
  .name = "AiotTask",
  .stack_size = 256 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for NTPTask */
osThreadId_t NTPTaskHandle;
const osThreadAttr_t NTPTask_attributes = {
  .name = "NTPTask",
  .stack_size = 512 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for WeatherTask */
osThreadId_t WeatherTaskHandle;
const osThreadAttr_t WeatherTask_attributes = {
  .name = "WeatherTask",
  .stack_size = 1024 * 4,
  .priority = (osPriority_t) osPriorityBelowNormal,
};
/* Definitions for CommandTask */
osThreadId_t CommandTaskHandle;
const osThreadAttr_t CommandTask_attributes = {
  .name = "CommandTask",
  .stack_size = 256 * 4,
  .priority = (osPriority_t) osPriorityAboveNormal,
};
/* Definitions for ESP_Mutex */
osMutexId_t ESP_MutexHandle;
const osMutexAttr_t ESP_Mutex_attributes = {
  .name = "ESP_Mutex"
};
/* Definitions for NTP_Mutex */
osMutexId_t NTP_MutexHandle;
const osMutexAttr_t NTP_Mutex_attributes = {
  .name = "NTP_Mutex"
};
/* USER CODE BEGIN PV */
uint8_t rx2char;
extern cb_data_t cb_data;
extern volatile unsigned char rx2Flag;
extern volatile char rx2Data[50];
volatile int tim3Flag1Sec=1;
volatile unsigned int tim3Sec;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_USART6_UART_Init(void);
static void MX_TIM3_Init(void);
static void MX_RTC_Init(void);
void Aiot_Task(void *argument);
void NTP_Task(void *argument);
void Weather_Task(void *argument);
void Command_Task(void *argument);

/* USER CODE BEGIN PFP */
char strBuff[MAX_ESP_COMMAND_LEN];
void MX_GPIO_LED_ON(int flag);
void MX_GPIO_LED_OFF(int flag);
void MX_GPIO_FAN_ON(int flag);
void MX_GPIO_FAN_OFF(int flag);
void esp_event(const char *recvBuf);
char sendBuf[MAX_UART_COMMAND_LEN]={0};
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
#define NTPTIME_TASK_PERIOD_MS 10000  // ntp 시간 10초마다 갱신
#define WEATHER_TASK_PERIOD_MS 10000  // 날씨정보 10초마다 갱신
#define MAX_HTTP_BUF 1024

extern char response[MAX_HTTP_BUF];

const char *API_KEY = "o6iIv1M5RHSoiL9TOaR0jw"; // 발급 받은 API KEY
const char *NX = "60";  // 지역 X좌표
const char *NY = "127"; // 지역 Y좌표
time_t ntp_time;
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */
  int ret = 0;
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART2_UART_Init();
  MX_USART6_UART_Init();
  MX_TIM3_Init();
  MX_RTC_Init();
  /* USER CODE BEGIN 2 */
  printf("Start main() - wifi\r\n");
  ret |= drv_uart_init();
  ret |= drv_esp_init();
  if(ret != 0)
  {
	  printf("Esp response error\r\n");
	  Error_Handler();
  }


  if(HAL_TIM_Base_Start_IT(&htim3) != HAL_OK)
  {
	  Error_Handler();
  }


  /* USER CODE END 2 */

  /* Init scheduler */
  osKernelInitialize();
  /* Create the mutex(es) */
  /* creation of ESP_Mutex */
  ESP_MutexHandle = osMutexNew(&ESP_Mutex_attributes);

  /* creation of NTP_Mutex */
  NTP_MutexHandle = osMutexNew(&NTP_Mutex_attributes);

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of AiotTask */
  AiotTaskHandle = osThreadNew(Aiot_Task, NULL, &AiotTask_attributes);

  /* creation of NTPTask */
  NTPTaskHandle = osThreadNew(NTP_Task, NULL, &NTPTask_attributes);

  /* creation of WeatherTask */
  WeatherTaskHandle = osThreadNew(Weather_Task, NULL, &WeatherTask_attributes);

  /* creation of CommandTask */
  CommandTaskHandle = osThreadNew(Command_Task, NULL, &CommandTask_attributes);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* USER CODE BEGIN RTOS_EVENTS */
  /* add events, ... */
  /* USER CODE END RTOS_EVENTS */

  /* Start scheduler */
  osKernelStart();

  /* We should never get here as control is now taken by the scheduler */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	// main()에서는 더 이상 처리할 것이 없음
	// 모든 기능은 FreeRTOS Task에서 처리
	osDelay(1000); // 안전을 위해 1초 대기
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_TimeTypeDef sTime = {0};
  RTC_DateTypeDef sDate = {0};
  RTC_AlarmTypeDef sAlarm = {0};

  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */

  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
  {
    Error_Handler();
  }

  /* USER CODE BEGIN Check_RTC_BKUP */

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  sTime.Hours = 0x0;
  sTime.Minutes = 0x0;
  sTime.Seconds = 0x0;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
  {
    Error_Handler();
  }
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
  sDate.Month = RTC_MONTH_JANUARY;
  sDate.Date = 0x1;
  sDate.Year = 0x0;

  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
  {
    Error_Handler();
  }

  /** Enable the Alarm A
  */
  sAlarm.AlarmTime.Hours = 0x0;
  sAlarm.AlarmTime.Minutes = 0x0;
  sAlarm.AlarmTime.Seconds = 0x0;
  sAlarm.AlarmTime.SubSeconds = 0x0;
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
  sAlarm.AlarmDateWeekDay = 0x1;
  sAlarm.Alarm = RTC_ALARM_A;
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}

/**
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 84-1;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 1000-1;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief USART6 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART6_UART_Init(void)
{

  /* USER CODE BEGIN USART6_Init 0 */

  /* USER CODE END USART6_Init 0 */

  /* USER CODE BEGIN USART6_Init 1 */

  /* USER CODE END USART6_Init 1 */
  huart6.Instance = USART6;
  huart6.Init.BaudRate = 38400;
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart6) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART6_Init 2 */

  /* USER CODE END USART6_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */
  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(FAN_GPIO_Port, FAN_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : LD2_Pin */
  GPIO_InitStruct.Pin = LD2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : FAN_Pin */
  GPIO_InitStruct.Pin = FAN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(FAN_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */
  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
void MX_GPIO_LED_ON(int pin)
{
	HAL_GPIO_WritePin(LD2_GPIO_Port, pin, GPIO_PIN_SET);
}
void MX_GPIO_LED_OFF(int pin)
{
	HAL_GPIO_WritePin(LD2_GPIO_Port, pin, GPIO_PIN_RESET);
}
void MX_GPIO_FAN_ON(int pin)
{
	HAL_GPIO_WritePin(FAN_GPIO_Port, pin, GPIO_PIN_SET);
}
void MX_GPIO_FAN_OFF(int pin)
{
	HAL_GPIO_WritePin(FAN_GPIO_Port, pin, GPIO_PIN_RESET);
}

void esp_event(const char *recvBuf)
{
    char strBuff[128];
    char *pArray[4] = {0,};

    // 1) 문자열 복사 (안전하게 처리)
    strncpy(strBuff, recvBuf, sizeof(strBuff)-1);
    strBuff[sizeof(strBuff)-1] = '\0';

    // 2) 개행문자 제거
    char *newline = strchr(strBuff, '\n');
    if (newline) *newline = '\0';
    newline = strchr(strBuff, '\r');
    if (newline) *newline = '\0';

    // 3) 파싱 (구분자 @, 공백, [, ] 처리)
    int idx = 0;
    char *token = strtok(strBuff, "[]@ ");
    while (token != NULL && idx < 4)
    {
        pArray[idx++] = token;
        token = strtok(NULL, "[]@ ");
    }

    // 디버깅 출력
    /*
    printf("Parsed: pArray[0]=%s, pArray[1]=%s, pArray[2]=%s\r\n",
           pArray[0] ? pArray[0] : "NULL",
           pArray[1] ? pArray[1] : "NULL",
           pArray[2] ? pArray[2] : "NULL");
    */
    // 4) 명령 실행
    if (pArray[1] && pArray[2])
    {
        if (strcmp(pArray[1], "LED") == 0)
        {
            if (strcmp(pArray[2], "ON") == 0) {
                LED_ON();
                printf("LED turned ON\r\n");
            }
            else if (strcmp(pArray[2], "OFF") == 0) {
                LED_OFF();
                printf("LED turned OFF\r\n");
            }
        }
        else if (strcmp(pArray[1], "FAN") == 0)
        {
            if (strcmp(pArray[2], "ON") == 0) {
                FAN_ON();
                printf("FAN turned ON\r\n");
            }
            else if (strcmp(pArray[2], "OFF") == 0) {
                FAN_OFF();
                printf("FAN turned OFF\r\n");
            }
        }
        else
        {
            printf("Unknown device: %s\r\n", pArray[1]);
        }
    }
    else
    {
        printf("Invalid command format: %s\r\n", recvBuf);
    }
}


void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)		//1ms 마다 호출
{
	static int tim3Cnt = 0;
	tim3Cnt++;
	if(tim3Cnt >= 1000) //1ms * 1000 = 1Sec
	{
		tim3Flag1Sec = 1;
		tim3Sec++;
		tim3Cnt = 0;
	}
}
/* USER CODE END 4 */

/* USER CODE BEGIN Header_Aiot_Task */
/**
  * @brief  Function implementing the AiotTask thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_Aiot_Task */
void Aiot_Task(void *argument)
{
  /* USER CODE BEGIN 5 */
  /* Infinite loop */
	AiotClient_Init();
	for(;;)
	{
		if (esp_get_status() != 0)
		{
		   printf("server connecting ...\r\n");
		   if(osMutexAcquire(ESP_MutexHandle, osWaitForever) == osOK)
			 {
			 	esp_client_conn();  // TCP 연결
			 	osMutexRelease(ESP_MutexHandle);
			 }
		}
		vTaskDelay(pdMS_TO_TICKS(10000)); // 10초
	}
  /* USER CODE END 5 */
}

/* USER CODE BEGIN Header_NTP_Task */
/**
* @brief Function implementing the NTPTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_NTP_Task */
void NTP_Task(void *argument)
{
  /* USER CODE BEGIN NTP_Task */
  /* Infinite loop */
    static time_t epoch;
    uint16_t length = 0;
	TickType_t xLastWakeTime = xTaskGetTickCount();
	const TickType_t xPeriod1 = pdMS_TO_TICKS(NTPTIME_TASK_PERIOD_MS);

	for(;;)
	{
		if(esp_get_status() == 0)  // TCP 연결 확인
		{
			if(osMutexAcquire(ESP_MutexHandle, osWaitForever) == osOK)
			{
				// UART 버퍼 초기화
				cb_data.length = 0;
				memset(cb_data.buf, 0, sizeof(cb_data.buf));

				// NTP 서버 설정 (매 요청 안전)
				if(esp_ntp_config() == 0)
				{
					if(esp_at_command((uint8_t *)"AT+CIPSNTPTIME?\r\n",
									  (uint8_t *)response, &length, 5000) == 0)
					{
						char *p = strtok(response, "\r\n");
						while(p != NULL)
						{
							if(parse_cipsntptime_line(p, &epoch) == 0)
							{
								printf("NTP request success!\r\n");
								printf("NTP Time (KST): %s", ctime(&epoch));

					            // Mutex로 전역 변수 갱신
								if(osMutexAcquire(NTP_MutexHandle, osWaitForever) == osOK)
								{
									ntp_time = epoch;
									osMutexRelease(NTP_MutexHandle);
								}

								break;
							}
							p = strtok(NULL, "\r\n");
						}
					}
				}

				osMutexRelease(ESP_MutexHandle);
			}
		}
		else
		{
			printf("TCP not connected!, reconnecting...\r\n");
			if(osMutexAcquire(ESP_MutexHandle, osWaitForever) == osOK)
			{
				esp_client_conn();
				osMutexRelease(ESP_MutexHandle);
			}
		}

		vTaskDelayUntil(&xLastWakeTime, xPeriod1); // 10초마다
	}
  /* USER CODE END NTP_Task */
}

/* USER CODE BEGIN Header_Weather_Task */
/**
* @brief Function implementing the WeatherTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_Weather_Task */

void Weather_Task(void *argument)
{
  /* USER CODE BEGIN Weather_Task */
  /* Infinite loop */
	static char buf[8192];
	    const char *apiKey = "o6iIv1M5RHSoiL9TOaR0jw";
	    const int nx=58, ny=125; // 강서구

	    for(;;)
	    {
	        if (osMutexAcquire(ESP_MutexHandle, osWaitForever) == osOK)
	        {
	            if (esp_weather_ultra_request(apiKey, nx, ny, buf, sizeof(buf)) == 0)
	                parse_weather_info(buf);
	            else
	                printf("weather request failed\r\n");

	            osMutexRelease(ESP_MutexHandle);
	        }

	        vTaskDelay(pdMS_TO_TICKS(60000)); // 60초~10분 권장
	    }
  /* USER CODE END Weather_Task */
}


/* USER CODE BEGIN Header_Command_Task */
/**
* @brief Function implementing the CommandTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_Command_Task */
void Command_Task(void *argument)
{
  /* USER CODE BEGIN Command_Task */
  /* Infinite loop */
	char localBuf[128];

	for(;;)
	{
		// TCP 수신(+IPD) 프레임 처리
		// Command_Task의 수신 처리 부분 예시
		if (cb_data.length > 0)
		{
		    // 멀티모드 +IPD 헤더: +IPD,<id>,<len>:...
		    char *ipd = strstr((char*)cb_data.buf, "+IPD,");
		    if (ipd) {
		        int id=-1;
		        sscanf(ipd, "+IPD,%d,", &id);

		        if (id == 0) {
		            // 서버에서 온 명령 (기존 LED/FAN 처리)
		            // ... 기존 로직 유지 ...
		        } else if (id == 1) {
		            // 날씨 응답 → Weather 함수 쪽에서 따로 수집하므로 여기서는 건드리지 않거나,
		            // 간단히 무시. (read_http_response_from_link()가 수집함)
		        }

		        // ⚠️ 전체 버퍼를 무조건 지우면 날씨/서버 충돌 가능
		        // 필요 부분만 소비하도록 조심하거나, 최소한 명령 처리 후에만 초기화:
		        // 여기서는 단순화를 위해 기존처럼 초기화하되,
		        // 날씨 수집은 read_http_response_from_link()에서 따로 라인으로 읽습니다.
		        memset(cb_data.buf, 0, sizeof(cb_data.buf));
		        cb_data.length = 0;
		    }
		}



		// UART2 콘솔 입력
		if(rx2Flag)
		{
		    char tmp[50];
		    strncpy(tmp, (char *)rx2Data, sizeof(tmp)-1);
		    tmp[sizeof(tmp)-1] = '\0';
		    tmp[strcspn(tmp, "\r\n")] = '\0'; // 개행 제거
		    printf("UART2 recv: %s\r\n", tmp);
		    rx2Flag = 0;
		}

		vTaskDelay(pdMS_TO_TICKS(20)); // 20ms 틱
	}
  /* USER CODE END Command_Task */
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
