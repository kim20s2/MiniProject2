// =============================
// Servo_Task.c
// =============================
#include "cmsis_os.h"
#include "main.h"
#include <math.h>
#include <stdio.h>

// TIM1 핸들 및 WEATHER 공유 변수
extern TIM_HandleTypeDef htim1;
extern osMutexId_t Weather_MutexHandle;
extern volatile int   g_pty;   // 0=없음, 1~7=강수

// --- 각도/펄스 설정 ----------------------------
#define SERVO_MIN_US      1000   // 0도 ≈ 1.0ms
#define SERVO_MAX_US      2000   // 180도 ≈ 2.0ms
#define SERVO_MIN_DEG     0.0f
#define SERVO_MAX_DEG     180.0f

#define SERVO_ANGLE_DRY    0.0f   // 비/눈 없음
#define SERVO_ANGLE_WET   90.0f   // 비/눈 있음

// --- 버튼(NUCLEO B1: PC13) --------------------
#define USER_BTN_PORT     GPIOC
#define USER_BTN_PIN      GPIO_PIN_13
// Nucleo 보드는 내부 풀업, 눌렀을 때 Low
#define BTN_PRESSED()     (HAL_GPIO_ReadPin(USER_BTN_PORT, USER_BTN_PIN) == GPIO_PIN_RESET)

// --- 오버라이드(버튼/명령으로 강제) ------------
// -1: 자동(실제 날씨 사용), 0: DRY 강제, 1: WET 강제
static volatile int s_override = -1;

// --- 유틸 -------------------------------------
static inline uint16_t clamp_u16(int v, int lo, int hi) {
    if (v < lo) return (uint16_t)lo;
    if (v > hi) return (uint16_t)hi;
    return (uint16_t)v;
}

// 1us 타이머(PSC=83, ARR=19999 가정): CCR=us
static void servo_set_pulse_us(uint16_t us) {
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, us);
}

// 0~180도 → 1000~2000us
void Servo_set_angle(float deg) {
    if (deg < SERVO_MIN_DEG) deg = SERVO_MIN_DEG;
    if (deg > SERVO_MAX_DEG) deg = SERVO_MAX_DEG;
    float ratio = (deg - SERVO_MIN_DEG) / (SERVO_MAX_DEG - SERVO_MIN_DEG);
    int pulse = (int)roundf(SERVO_MIN_US + ratio * (SERVO_MAX_US - SERVO_MIN_US));
    servo_set_pulse_us(clamp_u16(pulse, SERVO_MIN_US, SERVO_MAX_US));
}

static inline int is_precip_now(void) {
    // ★ 버튼/명령으로 강제한 상태가 있으면 그걸 사용
    int ov = s_override;
    if (ov >= 0) return ov;

    int p = -1;
    if (osMutexAcquire(Weather_MutexHandle, pdMS_TO_TICKS(50)) == osOK) {
        p = g_pty;
        osMutexRelease(Weather_MutexHandle);
    }
    return (p > 0); // 0=없음, 1~7=강수
}

static void apply_servo_by_wet(int wet) {
    float target = wet ? SERVO_ANGLE_WET : SERVO_ANGLE_DRY;
    Servo_set_angle(target);
    printf("[SERVO] %s -> angle=%d\r\n", wet ? "WET" : "DRY", (int)lroundf(target));

}

// 버튼 토글: DRY <-> WET (자동 모드 해제)
static void button_toggle_override(void) {
    if (s_override < 0) {
        // 자동에서 누르면 현재 상태의 반대로 강제
        int now = is_precip_now();
        s_override = now ? 0 : 1;
    } else {
        // 강제 중이면 DRY<->WET 토글
        s_override = (s_override == 0) ? 1 : 0;
    }
    apply_servo_by_wet(s_override);
    printf("[SERVO] override=%d (-1:auto,0:dry,1:wet)\r\n", s_override);
}
/*
void Servo_Task(void *argument)
{
    // ※ 안전장치: 혹시 메인에서 PWM Start가 빠졌어도 한 번 더 호출 (중복 호출 안전)
    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
    // 고급타이머(TIM1) 환경에서 MOE가 필요할 수 있음 → 한 번 보정
    __HAL_TIM_MOE_ENABLE(&htim1);

    // 시작 로그(태스크가 살아있는지 확인용)
    printf("[SERVO] task start\r\n");

    // 시작 위치(현재 날씨/오버라이드 기준)
    int wet = is_precip_now();
    apply_servo_by_wet(wet);

    // 버튼 디바운스용
    uint8_t last = BTN_PRESSED() ? 1 : 0;
    TickType_t lastEdge = 0;

    TickType_t lastBeat = xTaskGetTickCount(); // 하트비트(주기 로그)용

    for (;;) {
        // 1) 버튼 에지 감지(폴링 10ms)
        uint8_t now = BTN_PRESSED() ? 1 : 0;
        TickType_t tick = xTaskGetTickCount();
        if (last == 0 && now == 1) { // Not pressed -> Pressed
            if ((tick - lastEdge) > pdMS_TO_TICKS(150)) { // 디바운스 150ms
                button_toggle_override();
                lastEdge = tick;
            }
        }
        last = now;

        // 2) 자동 모드일 때만 날씨 변화 반영
        if (s_override < 0) {
            int w = is_precip_now();
            if (w != wet) {
                wet = w;
                apply_servo_by_wet(wet);
            }
        }

        // 3) 하트비트 로그(2초마다) — 태스크 동작 확인용
        if ((tick - lastBeat) > pdMS_TO_TICKS(2000)) {
            printf("[SERVO] alive (override=%d, wet=%d)\r\n", s_override, wet);
            lastBeat = tick;
        }

        vTaskDelay(pdMS_TO_TICKS(10));
    }
}
*/
void Servo_Task(void *argument)
{
}
}
