#include "cmsis_os2.h"
#include "stm32f4xx_hal.h"
#include "LED_FAN.h"
#include "PIR_Task.h"
#include <stdbool.h>
#include "FreeRTOS.h"
#include "task.h"
#include <stdio.h>

void PIR_Task(void *argument)
{
    osDelay(30000);  // 워밍업

    const uint32_t period = MS2T(50);     // 50 ms
    uint32_t next_wake   = osKernelGetTickCount() + period;

    volatile uint32_t OFF_WINDOW = MS2T(10000); // 무감지 10초면 OFF
    uint32_t now;

    uint8_t  hi_cnt = 0, lo_cnt = 0;
    const uint8_t HI_THR = 2;   // 100ms 이상 High면 감지
    const uint8_t LO_THR = 2;   // 100ms 이상 Low면 해제
    bool high_blocked = false;  // 현재 High 구간을 이미 처리했는지

    for (;;)
    {
        now = osKernelGetTickCount();
        GPIO_PinState s = HAL_GPIO_ReadPin(PIR_GPIO_Port, PIR_Pin);

        if (s == GPIO_PIN_SET) {
            if (hi_cnt < 255) hi_cnt++;
            lo_cnt = 0;

            // HIGH 유지 동안에는 무감지 타이머 계속 연장
            s_last_motion = now;

            // 상승 에지 시점(처음 HI_THR 도달)만 1회 처리
            if (!high_blocked && hi_cnt >= HI_THR) {
                printf("Sensing Something\r\n");   // ★ 딱 1번만 출력
                LED_ON();
                fan_hold = 1;                      // 원하시는 정책 유지
                FAN_ON();
                high_blocked = true;
            }
        } else {
            if (lo_cnt < 255) lo_cnt++;
            hi_cnt = 0;

            // 충분히 Low가 유지되면 다음 High를 다시 처리 가능
            if (high_blocked && lo_cnt >= LO_THR) {
                high_blocked = false;
            }
        }

        // 무감지 10초 경과 시 OFF
        if (s_last_motion != 0 && (now - s_last_motion) >= OFF_WINDOW) {
            fan_hold = 0;
            printf("Sensing Nothing\r\n");   // ★ 딱 1번만 출력
            FAN_OFF();
            LED_OFF();
            s_last_motion = 0;
        }

        osDelayUntil(next_wake);
        next_wake += period;
    }
}


