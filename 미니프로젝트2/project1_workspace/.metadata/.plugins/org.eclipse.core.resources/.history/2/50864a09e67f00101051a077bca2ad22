// =============================
// ntp_task.c
// =============================
#include "cmsis_os.h"
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "esp.h"

extern osMutexId_t ESP_MutexHandle;
extern osMutexId_t NTP_MutexHandle;
extern time_t ntp_time;

#define NTPTIME_TASK_PERIOD_MS 10000

void NTP_Task(void *argument)
{
    static time_t epoch;
    uint16_t length = 0;
    TickType_t last = xTaskGetTickCount();
    const TickType_t period = pdMS_TO_TICKS(NTPTIME_TASK_PERIOD_MS);
    static int s_ntp_cfg_ok = 0;

    for(;;)
    {
        if (esp_get_status() == 0) {
            if (osMutexAcquire(ESP_MutexHandle, osWaitForever) == osOK) {
                if (!s_ntp_cfg_ok) {
                    if (esp_ntp_config() == 0) s_ntp_cfg_ok = 1;
                	}
				if (esp_at_command((uint8_t*)"AT+CIPSNTPTIME?\r\n", (uint8_t*)response, &length, 5000) == 0) {
					char *p = strtok(response, "\r\n");
					printf("NTP connected!\r");
					while (p) {
						if (parse_cipsntptime_line(p, &epoch) == 0) {
							printf("NTP Time (KST): %s\r", ctime(&epoch));
							if (osMutexAcquire(NTP_MutexHandle, osWaitForever) == osOK) {
								ntp_time = epoch;
								osMutexRelease(NTP_MutexHandle);
							}
							break;
						}
						p = strtok(NULL, "\r\n");
					}
			}
                osMutexRelease(ESP_MutexHandle);
            }
        } else {
        	/*
            printf("NTP not connected!, reconnecting...\r\n");
            if (osMutexAcquire(ESP_MutexHandle, osWaitForever) == osOK) {
                esp_client_conn();
                osMutexRelease(ESP_MutexHandle);
            }
            */
        }
        vTaskDelayUntil(&last, period);
    }
}

